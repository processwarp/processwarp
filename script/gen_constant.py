#!/usr/bin/evn python
# -*- coding: utf-8 -*-

import argparse
import json

HEADER =  '''/**
 * THIS FILE WAS GENERATED BY A PROGRAM.
 * You should edit not this file but the source file to change value.
 */
'''

parser = argparse.ArgumentParser(description='This script is ...')
parser.add_argument('-c', '--cpp-dst', action='store', nargs=1,
                    const=None, default=None, type=str, choices=None,
                    help='generate constants for C/C++',
                    metavar=None)
parser.add_argument('-n', '--nodejs-dst', action='store', nargs=1,
                    const=None, default=None, type=str, choices=None,
                    help='generate constants for JavaScript(Node.js)',
                    metavar=None)
parser.add_argument('-j', '--java-dst', action='store', nargs=1,
                    const=None, default=None, type=str, choices=None,
                    help='generate constants for Java(Android)',
                    metavar=None)
parser.add_argument('input', action='store', nargs='+', const=None,
                    default=None, type=str, choices=None,
                    help='input json file',
                    metavar=None)
args = parser.parse_args()


def padding(line):
    if len(line) % 4 == 0:
        return ''
    else:
        return ' ' * (4 - (len(line) % 4))
    
def token_block_description(json_data, head = ''):
    if 'description' in json_data:
        desc =  head + '/**\n'
        desc += head + ' * {}\n'.format(json_data['description'])
        desc += head + ' */\n'
        return desc
    else:
        return ''

def token_value(type, idx, v, delimiter):
    if 'value' in v:
        if type == 'string':
            return delimiter + v['value'] + delimiter
        else:
            return str(v['value'])
    elif type == 'enum':
        return str(idx)

def token_description(line, v):
    if 'description' in v:
        return '  ' + padding(line + '  ') + '///< ' + v['description']
    else:
        return ''

if args.cpp_dst:
    out = open(args.cpp_dst[0], 'w')
    out.write(HEADER)
    out.write('#pragma once\n\n'
              '#include <string>\n\n'
              '#include "types.hpp"\n\n'
              'namespace processwarp {\n\n')
    for fname in args.input:
        print 'processing {}'.format(fname)
        json_data = json.load(open(fname, 'r'))
        # Set default type of C/C++ if not set.
        if 'c_type' not in json_data:
            if json_data['type'] == 'enum' or json_data['type'] == 'int':
                json_data['c_type'] = 'int'
            elif json_data['type'] == 'string':
                json_data['c_type'] = 'char'
                json_data['post_name'] = '[]'

        # Output namespace
        out.write(token_block_description(json_data))
        out.write('namespace ' + json_data['camel_name'] + ' {\n')

        # Output typedef
        if 'c_typedef' in json_data:
            out.write('typedef {} {};\n'.format(json_data['c_type'], json_data['c_typedef']))

        for idx, v in enumerate(json_data['values']):
            # Output a value line
            line = 'static const '
            if 'c_typedef' in json_data:
                line += json_data['c_typedef'] + ' '
            else:
                line += json_data['c_type'] + ' '
            line += v['name']
            if 'post_name' in json_data:
                line += json_data['post_name']
            line +=  ' '
            line += padding(line) + '= '
            line += token_value(json_data['type'], idx, v, '"') + ';'
            line += token_description(line, v) + '\n'
            out.write(line)

        # Output end of namespace
        out.write('}  // namespace ' + json_data['camel_name'] + '\n\n')
    out.write('}  // namespace processwarp\n')
    out.close()

if args.nodejs_dst:
    out = open(args.nodejs_dst[0], 'w')
    names = []
    out.write(HEADER)

    for fname in args.input:
        json_data = json.load(open(fname, 'r'))
        names.append(json_data['snake_name'])
        # Output name
        out.write(token_block_description(json_data, ''))
        out.write('export const {} = {{\n'.format(json_data['snake_name']))
        
        for idx, v in enumerate(json_data['values']):
            # Output a value line
            line = '  ' + v['name'] + ': '
            line += token_value(json_data['type'], idx, v, "'") + ','
            line += token_description(line, v) + '\n'
            out.write(line)

        # Output end of object
        out.write('};\n\n')
    out.close()

if args.java_dst:
    out = open(args.java_dst[0], 'w')
    out.write(HEADER)
    out.write('package org.processwarp.android.constant;\n\n')

    for fname in args.input:
        json_data = json.load(open(fname, 'r'))
        # Set default type of C/C++ if not set.
        if 'j_type' not in json_data:
            if json_data['type'] == 'enum' or json_data['type'] == 'int':
                json_data['j_type'] = 'int'
            elif json_data['type'] == 'string':
                json_data['j_type'] = 'String'

        # Output class name
        out.write(token_block_description(json_data))
        out.write('public class ' + json_data['camel_name'] + '{\n')

        for idx, v in enumerate(json_data['values']):
            # Output a value line
            line = '    public static final ' + json_data['j_type'] + ' ' + v['name'] + ' '
            line += padding(line) + '= '
            line += token_value(json_data['type'], idx, v, '"') + ';'
            line += token_description(line, v) + '\n'
            out.write(line)

        # Output end of class
        out.write('}\n')
    out.close()
